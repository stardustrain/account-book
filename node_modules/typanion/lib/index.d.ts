type BoundCoercionFn = () => BoundCoercionFn;
type CoercionFn = (v: any) => BoundCoercionFn;
type Coercion = [
    string,
    BoundCoercionFn
];
type ValidationState = {
    p?: string;
    errors?: string[];
    coercions?: Coercion[];
    coercion?: CoercionFn;
};
type Trait<Type> = {
    __trait: Type;
};
type InferType<U> = U extends Trait<infer V> ? V : never;
type LooseTest<U> = (value: U, test?: ValidationState) => boolean;
type StrictTest<U, V extends U> = (value: U, test?: ValidationState) => value is V;
type LooseValidator<U, V> = LooseTest<U> & Trait<V>;
type StrictValidator<U, V extends U> = StrictTest<U, V> & Trait<V>;
type AnyStrictValidator = StrictValidator<any, any>;
declare const simpleKeyRegExp: RegExp;
declare const colorStringRegExp: RegExp;
declare const colorStringAlphaRegExp: RegExp;
declare const base64RegExp: RegExp;
declare const uuid4RegExp: RegExp;
declare const iso8601RegExp: RegExp;
declare const makeTrait: <U>(value: U) => <V>() => U & Trait<V>;
declare function makeValidator<U, V extends U>({ test }: {
    test: StrictTest<U, V>;
}): StrictValidator<U, V>;
declare function makeValidator<U, V extends U = U>({ test }: {
    test: LooseTest<U>;
}): LooseValidator<U, V>;
declare function getPrintable(value: unknown): string;
declare function computeKey(state: ValidationState | undefined, key: string | number): string;
declare function makeCoercionFn(target: any, key: any): CoercionFn;
declare function makeSetter(target: any, key: any): (v: any) => void;
declare function plural(n: number, singular: string, plural: string): string;
declare function pushError({ errors, p }: ValidationState | undefined, message: string): boolean;
declare const isUnknown: () => StrictValidator<unknown, unknown>;
declare function isLiteral(expected: null): StrictValidator<unknown, null>;
declare function isLiteral(expected: true): StrictValidator<unknown, true>;
declare function isLiteral(expected: false): StrictValidator<unknown, false>;
declare function isLiteral<T extends number>(expected: T): StrictValidator<unknown, T>;
declare function isLiteral<T extends string>(expected: T): StrictValidator<unknown, T>;
declare function isLiteral<T>(expected: T): StrictValidator<unknown, T>;
declare const isString: () => StrictValidator<unknown, string>;
declare function isEnum<T extends boolean | string | number | null>(values: T[]): StrictValidator<unknown, T>;
declare function isEnum<T>(enumSpec: Record<string, T>): StrictValidator<unknown, T>;
declare const isBoolean: () => StrictValidator<unknown, boolean>;
declare const isNumber: () => StrictValidator<unknown, number>;
declare const isDate: () => StrictValidator<unknown, Date>;
declare const isArray: <T extends StrictValidator<any, any>>(spec: T, { delimiter }?: {
    delimiter?: string | RegExp | undefined;
}) => StrictValidator<unknown, InferType<T>[]>;
type AnyStrictValidatorTuple = AnyStrictValidator[] | [
];
type InferTypeFromTuple<T extends AnyStrictValidatorTuple> = {
    [K in keyof T]: InferType<T[K]>;
};
declare const isTuple: <T extends AnyStrictValidatorTuple>(spec: T, { delimiter }?: {
    delimiter?: string | RegExp | undefined;
}) => StrictValidator<unknown, InferTypeFromTuple<T>>;
type DeriveIndexUnlessNull<T extends AnyStrictValidator | null> = T extends null ? {} : InferType<T>;
declare const isDict: <T extends StrictValidator<any, any>>(spec: T, { keys: keySpec, }?: {
    keys?: StrictValidator<unknown, string> | null;
}) => StrictValidator<unknown, {
    [k: string]: InferType<T>;
}>;
type UndefinedProperties<T> = {
    [P in keyof T]-?: undefined extends T[P] ? P : never;
}[keyof T];
type ToOptional<T> = Partial<Pick<T, UndefinedProperties<T>>> & Pick<T, Exclude<keyof T, UndefinedProperties<T>>>;
declare const isObject: <T extends { [P in keyof T]: StrictValidator<any, any>; }, UnknownValidator extends StrictValidator<any, any> | null = null>(props: T, { extra: extraSpec, }?: {
    extra?: UnknownValidator | undefined;
}) => StrictValidator<unknown, ToOptional<{ [P_1 in keyof T]: InferType<T[P_1]>; } & DeriveIndexUnlessNull<UnknownValidator>>>;
declare const isInstanceOf: <T extends new (...args: any) => InstanceType<T>>(constructor: T) => StrictValidator<unknown, InstanceType<T>>;
declare const isOneOf: <T extends StrictValidator<any, any>>(specs: T[], { exclusive, }?: {
    exclusive?: boolean | undefined;
}) => StrictValidator<unknown, InferType<T>>;
declare const applyCascade: <T extends StrictValidator<any, any>>(spec: T, followups: (StrictTest<InferType<T>, InferType<T>> | LooseTest<InferType<T>>)[]) => StrictValidator<unknown, InferType<T>>;
declare const isOptional: <T extends StrictValidator<any, any>>(spec: T) => StrictValidator<unknown, InferType<T> | undefined>;
declare const isNullable: <T extends StrictValidator<any, any>>(spec: T) => StrictValidator<unknown, InferType<T> | null>;
declare const hasMinLength: <T extends {
    length: number;
}>(length: number) => LooseValidator<T, T>;
declare const hasMaxLength: <T extends {
    length: number;
}>(length: number) => LooseValidator<T, T>;
declare const hasExactLength: <T extends {
    length: number;
}>(length: number) => LooseValidator<T, T>;
declare const hasUniqueItems: <T>({ map, }?: {
    map?: ((value: T) => unknown) | undefined;
}) => LooseValidator<T[], T[]>;
declare const isNegative: () => LooseValidator<number, number>;
declare const isPositive: () => LooseValidator<number, number>;
declare const isAtLeast: (n: number) => LooseValidator<number, number>;
declare const isAtMost: (n: number) => LooseValidator<number, number>;
declare const isInInclusiveRange: (a: number, b: number) => LooseValidator<number, number>;
declare const isInExclusiveRange: (a: number, b: number) => LooseValidator<number, number>;
declare const isInteger: ({ unsafe, }?: {
    unsafe?: boolean | undefined;
}) => LooseValidator<number, number>;
declare const matchesRegExp: (regExp: RegExp) => LooseValidator<string, string>;
declare const isLowerCase: () => LooseValidator<string, string>;
declare const isUpperCase: () => LooseValidator<string, string>;
declare const isUUID4: () => LooseValidator<string, string>;
declare const isISO8601: () => LooseValidator<string, string>;
declare const isHexColor: ({ alpha, }: {
    alpha?: boolean | undefined;
}) => LooseValidator<string, string>;
declare const isBase64: () => LooseValidator<string, string>;
declare const isJSON: (spec?: AnyStrictValidator) => LooseValidator<string, string>;
declare const hasRequiredKeys: (requiredKeys: string[]) => LooseValidator<{
    [key: string]: unknown;
}, {
    [key: string]: unknown;
}>;
declare const hasForbiddenKeys: (forbiddenKeys: string[]) => LooseValidator<{
    [key: string]: unknown;
}, {
    [key: string]: unknown;
}>;
declare const hasMutuallyExclusiveKeys: (exclusiveKeys: string[]) => LooseValidator<{
    [key: string]: unknown;
}, {
    [key: string]: unknown;
}>;
declare enum KeyRelationship {
    Forbids = "Forbids",
    Requires = "Requires"
}
declare const hasKeyRelationship: (subject: string, relationship: KeyRelationship, others: string[], { ignore, }?: {
    ignore?: any[] | undefined;
}) => LooseValidator<{
    [key: string]: unknown;
}, {
    [key: string]: unknown;
}>;
export { BoundCoercionFn, CoercionFn, Coercion, ValidationState, Trait, InferType, LooseTest, StrictTest, LooseValidator, StrictValidator, AnyStrictValidator, simpleKeyRegExp, colorStringRegExp, colorStringAlphaRegExp, base64RegExp, uuid4RegExp, iso8601RegExp, makeTrait, makeValidator, getPrintable, computeKey, makeCoercionFn, makeSetter, plural, pushError, isUnknown, isLiteral, isString, isEnum, isBoolean, isNumber, isDate, isArray, isTuple, isDict, isObject, isInstanceOf, isOneOf, applyCascade, isOptional, isNullable, hasMinLength, hasMaxLength, hasExactLength, hasUniqueItems, isNegative, isPositive, isAtLeast, isAtMost, isInInclusiveRange, isInExclusiveRange, isInteger, matchesRegExp, isLowerCase, isUpperCase, isUUID4, isISO8601, isHexColor, isBase64, isJSON, hasRequiredKeys, hasForbiddenKeys, hasMutuallyExclusiveKeys, KeyRelationship, hasKeyRelationship };
