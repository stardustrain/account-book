"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addSettingWorkspaceConfiguration = exports.merge = void 0;
const tslib_1 = require("tslib");
const fslib_1 = require("@yarnpkg/fslib");
const comment_json_1 = tslib_1.__importDefault(require("comment-json"));
const mergeWith_1 = tslib_1.__importDefault(require("lodash/mergeWith"));
const merge = (cjsonData, patch) => mergeWith_1.default(cjsonData, patch, (cjsonValue, patchValue) => {
    // We need to preserve comments in CommentArrays, so we can't use spread or Sets
    if (Array.isArray(cjsonValue) && Array.isArray(patchValue)) {
        for (const patchItem of patchValue) {
            if (!cjsonValue.includes(patchItem)) {
                cjsonValue.push(patchItem);
            }
        }
        return cjsonValue;
    }
    return undefined;
});
exports.merge = merge;
const addSettingWorkspaceConfiguration = async (pnpApi, relativeFileName, patch) => {
    const topLevelInformation = pnpApi.getPackageInformation(pnpApi.topLevel);
    const projectRoot = fslib_1.npath.toPortablePath(topLevelInformation.packageLocation);
    const filePath = fslib_1.ppath.join(projectRoot, relativeFileName);
    const content = await fslib_1.xfs.existsPromise(filePath)
        ? await fslib_1.xfs.readFilePromise(filePath, `utf8`)
        : `{}`;
    const data = comment_json_1.default.parse(content);
    const patched = `${comment_json_1.default.stringify(exports.merge(data, patch), null, 2)}\n`;
    await fslib_1.xfs.mkdirPromise(fslib_1.ppath.dirname(filePath), { recursive: true });
    await fslib_1.xfs.changeFilePromise(filePath, patched, {
        automaticNewlines: true,
    });
};
exports.addSettingWorkspaceConfiguration = addSettingWorkspaceConfiguration;
