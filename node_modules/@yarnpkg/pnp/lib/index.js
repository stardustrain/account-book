module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 40:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "LinkType": () => /* reexport */ LinkType,
  "generateInlinedScript": () => /* reexport */ generateInlinedScript,
  "generateSplitScript": () => /* reexport */ generateSplitScript,
  "hydratePnpFile": () => /* reexport */ hydratePnpFile,
  "hydratePnpSource": () => /* reexport */ hydratePnpSource,
  "makeRuntimeApi": () => /* reexport */ makeRuntimeApi
});

// CONCATENATED MODULE: ./sources/types.ts
// Note: most of those types are useless for most users. Just check the
// PnpSettings and PnpApi types at the end and you'll be fine.
//
// Apart from that, note that the "Data"-suffixed types are the ones stored
// within the state files (hence why they only use JSON datatypes).
var LinkType;

(function (LinkType) {
  LinkType["HARD"] = "HARD";
  LinkType["SOFT"] = "SOFT";
})(LinkType || (LinkType = {}));
// CONCATENATED MODULE: ./sources/generatePrettyJson.ts
var PrettyJsonState;

(function (PrettyJsonState) {
  PrettyJsonState["DEFAULT"] = "DEFAULT";
  PrettyJsonState["TOP_LEVEL"] = "TOP_LEVEL";
  PrettyJsonState["FALLBACK_EXCLUSION_LIST"] = "FALLBACK_EXCLUSION_LIST";
  PrettyJsonState["FALLBACK_EXCLUSION_ENTRIES"] = "FALLBACK_EXCLUSION_ENTRIES";
  PrettyJsonState["FALLBACK_EXCLUSION_DATA"] = "FALLBACK_EXCLUSION_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_DATA"] = "PACKAGE_REGISTRY_DATA";
  PrettyJsonState["PACKAGE_REGISTRY_ENTRIES"] = "PACKAGE_REGISTRY_ENTRIES";
  PrettyJsonState["PACKAGE_STORE_DATA"] = "PACKAGE_STORE_DATA";
  PrettyJsonState["PACKAGE_STORE_ENTRIES"] = "PACKAGE_STORE_ENTRIES";
  PrettyJsonState["PACKAGE_INFORMATION_DATA"] = "PACKAGE_INFORMATION_DATA";
  PrettyJsonState["PACKAGE_DEPENDENCIES"] = "PACKAGE_DEPENDENCIES";
  PrettyJsonState["PACKAGE_DEPENDENCY"] = "PACKAGE_DEPENDENCY";
})(PrettyJsonState || (PrettyJsonState = {}));

const prettyJsonMachine = {
  [PrettyJsonState.DEFAULT]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // {
  //   "fallbackExclusionList": ...
  // }
  [PrettyJsonState.TOP_LEVEL]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: PrettyJsonState.FALLBACK_EXCLUSION_LIST,
      [`packageRegistryData`]: PrettyJsonState.PACKAGE_REGISTRY_DATA,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "fallbackExclusionList": [
  //   ...
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_LIST]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES
    }
  },
  // "fallbackExclusionList": [
  //   [...]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_DATA
    }
  },
  // "fallbackExclusionList": [
  //   [..., [...]]
  // ]
  [PrettyJsonState.FALLBACK_EXCLUSION_DATA]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   ...
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_REGISTRY_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [...]
  // ]
  [PrettyJsonState.PACKAGE_REGISTRY_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     ...
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_ENTRIES
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [...]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_STORE_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_INFORMATION_DATA
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       ...
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_INFORMATION_DATA]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: PrettyJsonState.PACKAGE_DEPENDENCIES,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packagePeers": [
  //         ...
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCIES]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_DEPENDENCY
    }
  },
  // "packageRegistryData": [
  //   [..., [
  //     [..., {
  //       "packageDependencies": [
  //         [...]
  //       ]
  //     }]
  //   ]]
  // ]
  [PrettyJsonState.PACKAGE_DEPENDENCY]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  }
};

function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `]`;
  return result;
}

function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[\n`;

  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `]`;
  return result;
}

function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);

    if (t + 1 < T) {
      result += `, `;
    }
  }

  result += `}`;
  return result;
}

function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{\n`;

  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`) continue;
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    if (t + 1 < T) result += `,`;
    result += `\n`;
  }

  result += indent;
  result += `}`;
  return result;
}

function generateNext(key, data, state, indent) {
  const {
    next
  } = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}

function generate(data, state, indent) {
  const {
    collapsed
  } = prettyJsonMachine[state];

  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }

  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }

  return JSON.stringify(data);
}

function generatePrettyJson(data) {
  return generate(data, PrettyJsonState.TOP_LEVEL, ``);
}
// CONCATENATED MODULE: ./sources/generateSerializedState.ts
// Keep this function is sync with its implementation in:
// @yarnpkg/core/sources/miscUtils.ts
function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers)) mappers = [mappers];
  const stringified = [];

  for (const mapper of mappers) stringified.push(asArray.map(value => mapper(value)));

  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? +1 : 0;

      if (comparison !== 0) {
        return comparison;
      }
    }

    return 0;
  });
  return indices.map(index => {
    return asArray[index];
  });
}

function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [({
    name,
    reference
  }) => name, ({
    name,
    reference
  }) => reference]);

  for (const {
    name,
    reference
  } of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`) fallbackExclusionList.set(name, references = new Set());
    references.add(reference);
  }

  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}

function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}

function generatePackageRegistryData(settings) {
  const packageRegistryData = [];

  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName]) => packageName === null ? `0` : `1${packageName}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);

    for (const [packageReference, {
      packageLocation,
      packageDependencies,
      packagePeers,
      linkType,
      discardFromLookup
    }] of sortMap(packageStore, ([packageReference]) => packageReference === null ? `0` : `1${packageReference}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName)) normalizedDependencies.push([packageName, packageReference]);

      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName]) => dependencyName)) normalizedDependencies.push([dependencyName, dependencyReference]);

      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : undefined;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : undefined;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }

  return packageRegistryData;
}

function generateSerializedState(settings) {
  return {
    // @eslint-ignore-next-line @typescript-eslint/naming-convention
    __info: [`This file is automatically generated. Do not touch it, or risk`, `your modifications being lost. We also recommend you not to read`, `it either without using the @yarnpkg/pnp package, as the data layout`, `is entirely unspecified and WILL change from a version to another.`],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}
// EXTERNAL MODULE: ./sources/hook.js
var hook = __webpack_require__(650);
var hook_default = /*#__PURE__*/__webpack_require__.n(hook);

// CONCATENATED MODULE: ./sources/generatePnpScript.ts

 // @ts-expect-error



function generateLoader(shebang, loader) {
  return [shebang ? `${shebang}\n` : ``, `/* eslint-disable */\n\n`, `try {\n`, `  Object.freeze({}).detectStrictMode = true;\n`, `} catch (error) {\n`, `  throw new Error(\`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.\`);\n`, `}\n`, `\n`, `var __non_webpack_module__ = module;\n`, `\n`, `function $$SETUP_STATE(hydrateRuntimeState, basePath) {\n`, loader.replace(/^/gm, `  `), `}\n`, `\n`, hook_default()()].join(``);
}

function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}

function generateInlinedSetup(data) {
  return [`return hydrateRuntimeState(${generatePrettyJson(data)}, {basePath: basePath || __dirname});\n`].join(``);
}

function generateSplitSetup(dataLocation) {
  return [`var path = require('path');\n`, `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});\n`, `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});\n`].join(``);
}

function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup(settings.dataLocation);
  const loaderFile = generateLoader(settings.shebang, setup);
  return {
    dataFile: generateJsonString(data),
    loaderFile
  };
}
// CONCATENATED MODULE: external "fs"
const external_fs_namespaceObject = require("fs");;
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_namespaceObject);

// CONCATENATED MODULE: external "path"
const external_path_namespaceObject = require("path");;
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_namespaceObject);

// CONCATENATED MODULE: external "util"
const external_util_namespaceObject = require("util");;
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/path.ts

var PathType;

(function (PathType) {
  PathType[PathType["File"] = 0] = "File";
  PathType[PathType["Portable"] = 1] = "Portable";
  PathType[PathType["Native"] = 2] = "Native";
})(PathType || (PathType = {}));

const PortablePath = {
  root: `/`,
  dot: `.`
};
const Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,

  /**
   * @deprecated
   */
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  rc: `.yarnrc.yml`
};
const npath = Object.create((external_path_default()));
const ppath = Object.create((external_path_default()).posix);

npath.cwd = () => process.cwd();

ppath.cwd = () => toPortablePath(process.cwd());

ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return external_path_default().posix.resolve(...segments);
  } else {
    return external_path_default().posix.resolve(ppath.cwd(), ...segments);
  }
};

const contains = function (pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to) return `.`;
  if (!from.endsWith(pathUtils.sep)) from = from + pathUtils.sep;

  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};

npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;

npath.contains = (from, to) => contains(npath, from, to);

ppath.contains = (from, to) => contains(ppath, from, to);

const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\\\\(\.\\)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/; // Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"

function fromPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(PORTABLE_PATH_REGEXP)) p = p.replace(PORTABLE_PATH_REGEXP, `$1`);else if (p.match(UNC_PORTABLE_PATH_REGEXP)) p = p.replace(UNC_PORTABLE_PATH_REGEXP, (match, p1, p2) => `\\\\${p1 ? `.\\` : ``}${p2}`);else return p;
  return p.replace(/\//g, `\\`);
} // Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"


function toPortablePath(p) {
  if (process.platform !== `win32`) return p;
  if (p.match(WINDOWS_PATH_REGEXP)) p = p.replace(WINDOWS_PATH_REGEXP, `/$1`);else if (p.match(UNC_WINDOWS_PATH_REGEXP)) p = p.replace(UNC_WINDOWS_PATH_REGEXP, (match, p1, p2) => `/unc/${p1 ? `.dot/` : ``}${p2}`);
  return p.replace(/\\/g, `/`);
}

function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}
function toFilename(filename) {
  if (npath.parse(filename).dir !== `` || ppath.parse(filename).dir !== ``) throw new Error(`Invalid filename: "${filename}"`);
  return filename;
}
// CONCATENATED MODULE: ./sources/loader/hydrateRuntimeState.ts

function hydrateRuntimeState(data, {
  basePath
}) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      var _a;

      if (packageName === null !== (packageReference === null)) throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = (_a = packageInformationData.discardFromLookup) !== null && _a !== void 0 ? _a : false; // @ts-expect-error: TypeScript isn't smart enough to understand the type assertion

      const packageLocator = {
        name: packageName,
        reference: packageReference
      };
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);

      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, {
          locator: packageLocator,
          discardFromLookup
        });
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;

        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }

      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,

        // we only need this for packages that are used by the currently running script
        // this is a lazy getter because `ppath.join` has some overhead
        get packageLocation() {
          // We use ppath.join instead of ppath.resolve because:
          // 1) packageInformationData.packageLocation is a relative path when part of the SerializedState
          // 2) ppath.join preserves trailing slashes
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }

      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}
// CONCATENATED MODULE: external "os"
const external_os_namespaceObject = require("os");;
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/algorithms/copyPromise.ts

 // 1980-01-01, like Fedora

const defaultTime = new Date(315532800 * 1000);
var LinkStrategy;

(function (LinkStrategy) {
  LinkStrategy["Allow"] = "allow";
  LinkStrategy["ReadOnly"] = "readOnly";
})(LinkStrategy || (LinkStrategy = {}));

async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  await destinationFs.mkdirPromise(destinationFs.pathUtils.dirname(destination), {
    recursive: true
  });
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, opts);

  for (const operation of prelayout) await operation();

  await Promise.all(postlayout.map(operation => {
    return operation();
  }));
}

async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b;

  const destinationStat = await maybeLStat(destinationFs, destination);
  const sourceStat = await sourceFs.lstatPromise(source);
  const referenceTime = opts.stableTime ? {
    mtime: defaultTime,
    atime: defaultTime
  } : sourceStat;
  let updated;

  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;

    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
      break;
  }

  if (updated || ((_a = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.mtime) === null || _a === void 0 ? void 0 : _a.getTime()) !== referenceTime.mtime.getTime() || ((_b = destinationStat === null || destinationStat === void 0 ? void 0 : destinationStat.atime) === null || _b === void 0 ? void 0 : _b.getTime()) !== referenceTime.atime.getTime()) {
    postlayout.push(() => updateTime(destination, referenceTime.atime, referenceTime.mtime));
    updated = true;
  }

  if (destinationStat === null || (destinationStat.mode & 0o777) !== (sourceStat.mode & 0o777)) {
    postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 0o777));
    updated = true;
  }

  return updated;
}

async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}

async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  let updated = false;

  if (destinationStat === null) {
    prelayout.push(async () => destinationFs.mkdirPromise(destination, {
      mode: sourceStat.mode
    }));
    updated = true;
  }

  const entries = await sourceFs.readdirPromise(source);

  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async entry => {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), opts);
    }));

    if (entriesUpdateStatus.some(status => status)) {
      updated = true;
    }
  }

  return updated;
}

const isCloneSupportedCache = new WeakMap();

function makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  return async () => {
    await opFs.linkPromise(source, destination);

    if (linkStrategy === LinkStrategy.ReadOnly) {
      // We mutate the stat, otherwise it'll be reset by copyImpl
      sourceStat.mode &= ~0o222;
      await opFs.chmodPromise(destination, sourceStat.mode);
    }
  };
}

function makeCloneLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  const isCloneSupported = isCloneSupportedCache.get(opFs);

  if (typeof isCloneSupported === `undefined`) {
    return async () => {
      try {
        await opFs.copyFilePromise(source, destination, (external_fs_default()).constants.COPYFILE_FICLONE_FORCE);
        isCloneSupportedCache.set(opFs, true);
      } catch (err) {
        if (err.code === `ENOSYS` || err.code === `ENOTSUP`) {
          isCloneSupportedCache.set(opFs, false);
          await makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy)();
        } else {
          throw err;
        }
      }
    };
  } else {
    if (isCloneSupported) {
      return async () => opFs.copyFilePromise(source, destination, (external_fs_default()).constants.COPYFILE_FICLONE_FORCE);
    } else {
      return makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy);
    }
  }
}

async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  var _a;

  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  const linkStrategy = (_a = opts.linkStrategy) !== null && _a !== void 0 ? _a : null;
  const op = destinationFs === sourceFs ? linkStrategy !== null ? makeCloneLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.copyFilePromise(source, destination, (external_fs_default()).constants.COPYFILE_FICLONE) : linkStrategy !== null ? makeLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
  prelayout.push(async () => op());
  return true;
}

async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }

  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/FakeFS.ts



class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }

  async *genTraversePromise(init, {
    stableSort = false
  } = {}) {
    const stack = [init];

    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);

      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);

        if (stableSort) {
          for (const entry of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }

  async removePromise(p, {
    recursive = true,
    maxRetries = 5
  } = {}) {
    let stat;

    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map(entry => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      } // 5 gives 1s worth of retries at worst


      let t = 0;

      do {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
            if (maxRetries === 0) {
              break;
            } else {
              await new Promise(resolve => setTimeout(resolve, t * 100));
              continue;
            }
          } else {
            throw error;
          }
        }
      } while (t++ < maxRetries);
    } else {
      await this.unlinkPromise(p);
    }
  }

  removeSync(p, {
    recursive = true
  } = {}) {
    let stat;

    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      if (recursive) for (const entry of this.readdirSync(p)) this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }

  async mkdirpPromise(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) await this.chmodPromise(subPath, chmod);

        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  mkdirpSync(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) this.chmodSync(subPath, chmod);

        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }

  async copyPromise(destination, source, {
    baseFs = this,
    overwrite = true,
    stableSort = false,
    stableTime = false,
    linkStrategy = null
  } = {}) {
    return await copyPromise(this, destination, baseFs, source, {
      overwrite,
      stableSort,
      stableTime,
      linkStrategy
    });
  }

  copySync(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);

    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);

      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    this.chmodSync(destination, mode);
  }

  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }

  async changeFileBufferPromise(p, content) {
    let current = Buffer.alloc(0);

    try {
      current = await this.readFilePromise(p);
    } catch (error) {// ignore errors, no big deal
    }

    if (Buffer.compare(current, content) === 0) return;
    await this.writeFilePromise(p, content);
  }

  async changeFileTextPromise(p, content, {
    automaticNewlines
  } = {}) {
    let current = ``;

    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    await this.writeFilePromise(p, normalizedContent);
  }

  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }

  changeFileBufferSync(p, content) {
    let current = Buffer.alloc(0);

    try {
      current = this.readFileSync(p);
    } catch (error) {// ignore errors, no big deal
    }

    if (Buffer.compare(current, content) === 0) return;
    this.writeFileSync(p, content);
  }

  changeFileTextSync(p, content, {
    automaticNewlines = false
  } = {}) {
    let current = ``;

    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {// ignore errors, no big deal
    }

    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent) return;
    this.writeFileSync(p, normalizedContent);
  }

  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }

  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }

  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1000 / 60;
    const startTime = Date.now();
    let fd = null; // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.

    const isAlive = async () => {
      let pid;

      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        // If we can't read the file repeatedly, we assume the process was
        // aborted before even writing finishing writing the payload.
        return Date.now() - startTime < 500;
      }

      try {
        // "As a special case, a signal of 0 can be used to test for the
        // existence of a process" - so we check whether it's alive.
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };

    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!(await isAlive())) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error) {// No big deal if we can't remove it. Just fallback to wait for
              // it to be eventually released by its owner.
            }
          }

          if (Date.now() - startTime < 60 * 1000) {
            await new Promise(resolve => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }

    await this.writePromise(fd, JSON.stringify([process.pid]));

    try {
      return await callback();
    } finally {
      try {
        // closePromise needs to come before unlinkPromise otherwise another process can attempt
        // to get the file handle after the unlink but before close resuling in
        // EPERM: operation not permitted, open
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {// noop
      }
    }
  }

  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }

  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`) p = result;

    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }

}
FakeFS.DEFAULT_TIME = 315532800;
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }

}

function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null) return external_os_namespaceObject.EOL;
  const crlf = matches.filter(nl => nl === `\r\n`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r\n` : `\n`;
}

function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/errors.ts
function makeError(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {
    code
  });
}

function EBUSY(message) {
  return makeError(`EBUSY`, message);
}
function ENOSYS(message, reason) {
  return makeError(`ENOSYS`, `${message}, ${reason}`);
}
function EINVAL(reason) {
  return makeError(`EINVAL`, `invalid argument, ${reason}`);
}
function EBADF(reason) {
  return makeError(`EBADF`, `bad file descriptor, ${reason}`);
}
function ENOENT(reason) {
  return makeError(`ENOENT`, `no such file or directory, ${reason}`);
}
function ENOTDIR(reason) {
  return makeError(`ENOTDIR`, `not a directory, ${reason}`);
}
function EISDIR(reason) {
  return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
}
function EEXIST(reason) {
  return makeError(`EEXIST`, `file already exists, ${reason}`);
}
function EROFS(reason) {
  return makeError(`EROFS`, `read-only filesystem, ${reason}`);
}
function ENOTEMPTY(reason) {
  return makeError(`ENOTEMPTY`, `directory not empty, ${reason}`);
}
function EOPNOTSUPP(reason) {
  return makeError(`EOPNOTSUPP`, `operation not supported, ${reason}`);
} // ------------------------------------------------------------------------

function ERR_DIR_CLOSED() {
  return makeError(`ERR_DIR_CLOSED`, `Directory handle was closed`);
} // ------------------------------------------------------------------------

class LibzipError extends Error {
  constructor(message, code) {
    super(message);
    this.name = `Libzip Error`;
    this.code = code;
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/NodeFS.ts




class NodeFS extends BasePortableFakeFS {
  constructor(realFs = (external_fs_default())) {
    super();
    this.realFs = realFs; // @ts-expect-error

    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }

  getExtractHint() {
    return false;
  }

  getRealPath() {
    return PortablePath.root;
  }

  resolve(p) {
    return ppath.resolve(p);
  }

  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }

  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then(dir => {
      return Object.defineProperty(dir, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
    });
  }

  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
  }

  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }

  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }

  closeSync(fd) {
    this.realFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }

  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }

  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then(path => {
      return npath.toPortablePath(path);
    });
  }

  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }

  async existsPromise(p) {
    return await new Promise(resolve => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }

  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }

  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }

  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }

  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }

  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }

  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        // @ts-expect-error - The node typings doesn't know about the options
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }

  fstatSync(fd, opts) {
    if (opts) {
      // @ts-expect-error - The node typings doesn't know about the options
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }

  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        // @ts-expect-error - TS does not know this takes options
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }

  lstatSync(p, opts) {
    if (opts) {
      // @ts-expect-error - TS does not know this takes options
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }

  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }

  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }

  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }

  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }

  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }

  async lutimesPromiseImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`) throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  lutimesSyncImpl(p, atime, mtime) {
    // @ts-expect-error: Not yet in DefinitelyTyped
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`) throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, npath.fromPortablePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }

  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }

  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      // TODO: always pass opts when min node version is 12.10+
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }

  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }

  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }

  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }

  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }

  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }

  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await new Promise((resolve, reject) => {
      if (withFileTypes) {
        this.realFs.readdir(npath.fromPortablePath(p), {
          withFileTypes: true
        }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback(value => resolve(value), reject));
      }
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    if (withFileTypes) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), {
        withFileTypes: true
      });
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }

  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then(path => {
      return npath.toPortablePath(path);
    });
  }

  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }

  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }

  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }

  watch(p, a, b) {
    return this.realFs.watch(npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.realFs.watchFile(npath.fromPortablePath(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }

  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/ProxiedFS.ts

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }

  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }

  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }

  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }

  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), {
      path: p
    });
  }

  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), {
      path: p
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }

  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }

  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }

  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }

  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }

  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }

  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }

  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }

  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }

  async lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }

  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }

  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }

  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }

  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }

  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }

  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }

  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }

  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }

  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }

  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }

  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }

  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }

  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }

  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target)) return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }

  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target)) return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }

  async readFilePromise(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirPromise(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirSync(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }

  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }

  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }

  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }

  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  watchFile(p, a, b) {
    return this.baseFs.watchFile(this.mapToBase(p), // @ts-expect-error
    a, b);
  }

  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }

  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/VirtualFS.ts



const NUMBER_REGEXP = /^[0-9]+$/; // $0: full path
// $1: virtual folder
// $2: virtual segment
// $3: hash
// $4: depth
// $5: subpath

const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  constructor({
    baseFs = new NodeFS()
  } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }

  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`) throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT)) throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`); // Obtains the relative distance between the virtual path and its actual target

    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`); // Counts how many levels we need to go back to start applying the rest of the path

    let depth = 0;

    while (depth < segments.length && segments[depth] === `..`) depth += 1;

    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }

  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5]) return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4]) return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum) return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }

  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return this.baseFs.realpathSync(p);
    if (!match[5]) return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match) return await this.baseFs.realpathPromise(p);
    if (!match[5]) return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }

  mapToBase(p) {
    if (this.pathUtils.isAbsolute(p)) return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP);
  }

  mapFromBase(p) {
    return p;
  }

}
// CONCATENATED MODULE: external "module"
const external_module_namespaceObject = require("module");;
// CONCATENATED MODULE: ../../.yarn/cache/resolve.exports-npm-1.0.2-bbb8d62ef6-1de1e50dc6.zip/node_modules/resolve.exports/dist/index.mjs
/**
 * @param {object} exports
 * @param {Set<string>} keys
 */
function loop(exports, keys) {
	if (typeof exports === 'string') {
		return exports;
	}

	if (exports) {
		let idx, tmp;
		if (Array.isArray(exports)) {
			for (idx=0; idx < exports.length; idx++) {
				if (tmp = loop(exports[idx], keys)) return tmp;
			}
		} else {
			for (idx in exports) {
				if (keys.has(idx)) {
					return loop(exports[idx], keys);
				}
			}
		}
	}
}

/**
 * @param {string} name The package name
 * @param {string} entry The target entry, eg "."
 * @param {number} [condition] Unmatched condition?
 */
function bail(name, entry, condition) {
	throw new Error(
		condition
		? `No known conditions for "${entry}" entry in "${name}" package`
		: `Missing "${entry}" export in "${name}" package`
	);
}

/**
 * @param {string} name the package name
 * @param {string} entry the target path/import
 */
function toName(name, entry) {
	return entry === name ? '.'
		: entry[0] === '.' ? entry
		: entry.replace(new RegExp('^' + name + '\/'), './');
}

/**
 * @param {object} pkg package.json contents
 * @param {string} [entry] entry name or import path
 * @param {object} [options]
 * @param {boolean} [options.browser]
 * @param {boolean} [options.require]
 * @param {string[]} [options.conditions]
 */
function resolve(pkg, entry='.', options={}) {
	let { name, exports } = pkg;

	if (exports) {
		let { browser, require, conditions=[] } = options;

		let target = toName(name, entry);
		if (target[0] !== '.') target = './' + target;

		if (typeof exports === 'string') {
			return target === '.' ? exports : bail(name, target);
		}

		let allows = new Set(['default', ...conditions]);
		allows.add(require ? 'require' : 'import');
		allows.add(browser ? 'browser' : 'node');

		let key, tmp, isSingle=false;

		for (key in exports) {
			isSingle = key[0] !== '.';
			break;
		}

		if (isSingle) {
			return target === '.'
				? loop(exports, allows) || bail(name, target, 1)
				: bail(name, target);
		}

		if (tmp = exports[target]) {
			return loop(tmp, allows) || bail(name, target, 1);
		}

		for (key in exports) {
			tmp = key[key.length - 1];
			if (tmp === '/' && target.startsWith(key)) {
				return (tmp = loop(exports[key], allows))
					? (tmp + target.substring(key.length))
					: bail(name, target, 1);
			}
			if (tmp === '*' && target.startsWith(key.slice(0, -1))) {
				// do not trigger if no *content* to inject
				if (target.substring(key.length - 1).length > 0) {
					return (tmp = loop(exports[key], allows))
						? tmp.replace('*', target.substring(key.length - 1))
						: bail(name, target, 1);
				}
			}
		}

		return bail(name, target);
	}
}

/**
 * @param {object} pkg
 * @param {object} [options]
 * @param {string|boolean} [options.browser]
 * @param {string[]} [options.fields]
 */
function legacy(pkg, options={}) {
	let i=0, value,
		browser = options.browser,
		fields = options.fields || ['module', 'main'];

	if (browser && !fields.includes('browser')) {
		fields.unshift('browser');
	}

	for (; i < fields.length; i++) {
		if (value = pkg[fields[i]]) {
			if (typeof value == 'string') {
				//
			} else if (typeof value == 'object' && fields[i] == 'browser') {
				if (typeof browser == 'string') {
					value = value[browser=toName(pkg.name, browser)];
					if (value == null) return browser;
				}
			} else {
				continue;
			}

			return typeof value == 'string'
				? ('./' + value.replace(/^\.?\//, ''))
				: value;
		}
	}
}

// CONCATENATED MODULE: ./sources/loader/internalTools.ts

var ErrorCode;

(function (ErrorCode) {
  ErrorCode["API_ERROR"] = "API_ERROR";
  ErrorCode["BUILTIN_NODE_RESOLUTION_FAILED"] = "BUILTIN_NODE_RESOLUTION_FAILED";
  ErrorCode["MISSING_DEPENDENCY"] = "MISSING_DEPENDENCY";
  ErrorCode["MISSING_PEER_DEPENDENCY"] = "MISSING_PEER_DEPENDENCY";
  ErrorCode["QUALIFIED_PATH_RESOLUTION_FAILED"] = "QUALIFIED_PATH_RESOLUTION_FAILED";
  ErrorCode["INTERNAL"] = "INTERNAL";
  ErrorCode["UNDECLARED_DEPENDENCY"] = "UNDECLARED_DEPENDENCY";
  ErrorCode["UNSUPPORTED"] = "UNSUPPORTED";
})(ErrorCode || (ErrorCode = {})); // Some errors are exposed as MODULE_NOT_FOUND for compatibility with packages
// that expect this umbrella error when the resolution fails


const MODULE_NOT_FOUND_ERRORS = new Set([ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, ErrorCode.MISSING_DEPENDENCY, ErrorCode.MISSING_PEER_DEPENDENCY, ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, ErrorCode.UNDECLARED_DEPENDENCY]);
/**
 * Simple helper function that assign an error code to an error, so that it can more easily be caught and used
 * by third-parties.
 */

function internalTools_makeError(pnpCode, message, data = {}) {
  const code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: { ...propertySpec,
      value: code
    },
    pnpCode: { ...propertySpec,
      value: pnpCode
    },
    data: { ...propertySpec,
      value: data
    }
  });
}
/**
 * Returns the module that should be used to resolve require calls. It's usually the direct parent, except if we're
 * inside an eval expression.
 */

function getIssuerModule(parent) {
  let issuer = parent;

  while (issuer && (issuer.id === `[eval]` || issuer.id === `<repl>` || !issuer.filename)) issuer = issuer.parent;

  return issuer || null;
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}
// CONCATENATED MODULE: ./sources/loader/makeApi.ts






function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL); // @ts-expect-error

  const builtinModules = new Set(external_module_namespaceObject.Module.builtinModules || Object.keys(process.binding(`natives`)));

  const isBuiltinModule = request => builtinModules.has(request) || request.startsWith(`node:`); // Splits a require request into its components, or return null if the request is a file path


  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/; // Matches if the path starts with a valid path qualifier (./, ../, /)
  // eslint-disable-next-line no-unused-vars

  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/; // Matches if the path must point to a directory (ie ends with /)

  const isDirRegExp = /\/$/; // Matches if the path starts with a relative path qualifier (./, ../)

  const isRelativeRegexp = /^\.{0,2}\//; // We only instantiate one of those so that we can use strict-equal comparisons

  const topLevelLocator = {
    name: null,
    reference: null
  }; // Used for compatibility purposes - cf setupCompatibilityLayer

  const fallbackLocators = []; // To avoid emitting the same warning multiple times

  const emittedWarnings = new Set();
  if (runtimeState.enableTopLevelFallback === true) fallbackLocators.push(topLevelLocator);

  if (opts.compatibilityMode !== false) {
    // ESLint currently doesn't have any portable way for shared configs to
    // specify their own plugins that should be used (cf issue #10125). This
    // will likely get fixed at some point but it'll take time, so in the
    // meantime we'll just add additional fallback entries for common shared
    // configs.
    // Similarly, Gatsby generates files within the `public` folder located
    // within the project, but doesn't pre-resolve the `require` calls to use
    // its own dependencies. Meaning that when PnP see a file from the `public`
    // folder making a require, it thinks that your project forgot to list one
    // of your dependencies.
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);

      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({
              name,
              reference
            });
          }
        }
      }
    }
  }
  /**
   * The setup code will be injected here. The tables listed below are guaranteed to be filled after the call to
   * the $$DYNAMICALLY_GENERATED_CODE function.
   */


  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  /**
   * Allows to print useful logs just be setting a value in the environment
   */

  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }

  function trace(entry) {
    var _a, _b, _c, _d, _e, _f;

    const colors = (_c = (_b = (_a = process.stderr) === null || _a === void 0 ? void 0 : _a.hasColors) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : process.stdout.isTTY;

    const c = (n, str) => `\u001b[${n}m${str}\u001b[0m`;

    const error = entry.error;
    if (error) console.error(c(`31;1`, `✖ ${(_d = entry.error) === null || _d === void 0 ? void 0 : _d.message.replace(/\n.*/s, ``)}`));else console.error(c(`33;1`, `‼ Resolution`));
    if (entry.args.length > 0) console.error();

    for (const arg of entry.args) console.error(`  ${c(`37;1`, `In ←`)} ${(0,external_util_namespaceObject.inspect)(arg, {
      colors,
      compact: true
    })}`);

    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out →`)} ${(0,external_util_namespaceObject.inspect)(entry.result, {
        colors,
        compact: true
      })}`);
    }

    const stack = (_f = (_e = new Error().stack.match(/(?<=^ +)at.*/gm)) === null || _e === void 0 ? void 0 : _e.slice(2)) !== null && _f !== void 0 ? _f : [];

    if (stack.length > 0) {
      console.error();

      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }

    console.error();
  }

  function maybeLog(name, fn) {
    if (opts.allowDebug === false) return fn;

    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);

          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }

    return fn;
  }
  /**
   * Returns information about a package in a safe way (will throw if they cannot be retrieved)
   */


  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);

    if (!packageInformation) {
      throw internalTools_makeError(ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
    }

    return packageInformation;
  }
  /**
   * Returns whether the specified locator is a dependency tree root (in which case it's part of the project) or not
   */


  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null) return true;

    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots) if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference) return true;

    return false;
  }
  /**
   * Implements the node resolution for the "exports" field
   *
   * @returns The remapped path or `null` if the package doesn't have a package.json or an "exports" field
   */


  function applyNodeExportsResolution(unqualifiedPath) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });

    if (locator === null) {
      throw internalTools_makeError(ErrorCode.INTERNAL, `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`);
    }

    const {
      packageLocation
    } = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath)) return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    let subpath = ppath.contains(packageLocation, unqualifiedPath);

    if (subpath === null) {
      throw internalTools_makeError(ErrorCode.INTERNAL, `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`);
    }

    if (!isRelativeRegexp.test(subpath)) subpath = `./${subpath}`;
    const resolvedExport = resolve(pkgJson, ppath.normalize(subpath), {
      browser: false,
      require: true,
      // TODO: implement support for the --conditions flag
      // Waiting on https://github.com/nodejs/node/issues/36935
      conditions: []
    });
    if (typeof resolvedExport === `string`) return ppath.join(packageLocation, resolvedExport);
    return null;
  }
  /**
   * Implements the node resolution for folder access and extension selection
   */


  function applyNodeExtensionResolution(unqualifiedPath, candidates, {
    extensions
  }) {
    let stat;

    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {} // If the file exists and is a file, we can stop right there


    if (stat && !stat.isDirectory()) return opts.fakeFs.realpathSync(unqualifiedPath); // If the file is a directory, we must check if it contains a package.json with a "main" entry

    if (stat && stat.isDirectory()) {
      let pkgJson;

      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {}

      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main) nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main); // If the "main" field changed the path, we start again from this new location

      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {
          extensions
        });

        if (resolution !== null) {
          return resolution;
        }
      }
    } // Otherwise we check if we find a file that match one of the supported extensions


    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);

      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    } // Otherwise, we check if the path is a folder - in such a case, we try to use its index


    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({
          dir: unqualifiedPath,
          name: `index`,
          ext: extensions[i]
        });
        candidates.push(candidateFile);

        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    } // Otherwise there's nothing else we can do :(


    return null;
  }
  /**
   * This function creates fake modules that can be used with the _resolveFilename function.
   * Ideally it would be nice to be able to avoid this, since it causes useless allocations
   * and cannot be cached efficiently (we recompute the nodeModulePaths every time).
   *
   * Fortunately, this should only affect the fallback, and there hopefully shouldn't have a
   * lot of them.
   */


  function makeFakeModule(path) {
    // @ts-expect-error
    const fakeModule = new external_module_namespaceObject.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = external_module_namespaceObject.Module._nodeModulePaths(path);
    return fakeModule;
  }
  /**
   * Forward the resolution to the next resolver (usually the native one)
   */


  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`)) issuer = ppath.join(issuer, `internal.js`); // Since we would need to create a fake module anyway (to call _resolveLookupPath that
    // would give us the paths to give to _resolveFilename), we can as well not use
    // the {paths} option at all, since it internally makes _resolveFilename create another
    // fake module anyway.

    return external_module_namespaceObject.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, {
      plugnplay: false
    });
  }
  /**
   *
   */


  function isPathIgnored(path) {
    if (ignorePattern === null) return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null) return false;

    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * This key indicates which version of the standard is implemented by this resolver. The `std` key is the
   * Plug'n'Play standard, and any other key are third-party extensions. Third-party extensions are not allowed
   * to override the standard, and can only offer new methods.
   *
   * If a new version of the Plug'n'Play standard is released and some extensions conflict with newly added
   * functions, they'll just have to fix the conflicts and bump their own version number.
   */


  const VERSIONS = {
    std: 3,
    resolveVirtual: 1,
    getAllLocators: 1
  };
  /**
   * We export a special symbol for easy access to the top level locator.
   */

  const topLevel = topLevelLocator;
  /**
   * Gets the package information for a given locator. Returns null if they cannot be retrieved.
   */

  function getPackageInformation({
    name,
    reference
  }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore) return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation) return null;
    return packageInformation;
  }
  /**
   * Find all packages that depend on the specified one.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findPackageDependents({
    name,
    reference
  }) {
    const dependents = [];

    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null) continue;

      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null) continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference) continue; // Don't forget that all packages depend on themselves

        if (dependentName === name && dependentReference === reference) continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }

    return dependents;
  }
  /**
   * Find all packages that broke the peer dependency on X, starting from Y.
   *
   * Note: This is a private function; we expect consumers to implement it
   * themselves. We keep it that way because this implementation isn't
   * optimized at all, since we only need it when printing errors.
   */


  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = new Map();
    const alreadyVisited = new Set();

    const traversal = currentPackage => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier)) return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);

      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);

        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`) brokenPackages.set(dependent.name, brokenSet = new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };

    traversal(initialPackage);
    const brokenList = [];

    for (const name of [...brokenPackages.keys()].sort()) for (const reference of [...brokenPackages.get(name)].sort()) brokenList.push({
      name,
      reference
    });

    return brokenList;
  }
  /**
   * Finds the package locator that owns the specified path. If none is found, returns null instead.
   */


  function findPackageLocator(location, {
    resolveIgnored = false,
    includeDiscardFromLookup = false
  } = {}) {
    if (isPathIgnored(location) && !resolveIgnored) return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp)) relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`)) relativeLocation = `${relativeLocation}/`;

    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);

      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }

      return entry.locator;
    } while (relativeLocation !== ``);

    return null;
  }
  /**
   * Transforms a request (what's typically passed as argument to the require function) into an unqualified path.
   * This path is called "unqualified" because it only changes the package name to the package location on the disk,
   * which means that the end result still cannot be directly accessed (for example, it doesn't try to resolve the
   * file extension, or to resolve directories to their "index.js" content). Use the "resolveUnqualified" function
   * to convert them to fully-qualified paths, or just use "resolveRequest" that do both operations in one go.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveToUnqualified(request, issuer, {
    considerBuiltins = true
  } = {}) {
    // The 'pnpapi' request is reserved and will always return the path to the PnP file, from everywhere
    if (request === `pnpapi`) return npath.toPortablePath(opts.pnpapiResolution); // Bailout if the request is a native module

    if (considerBuiltins && isBuiltinModule(request)) return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer); // We allow disabling the pnp resolution for some subpaths.
    // This is because some projects, often legacy, contain multiple
    // levels of dependencies (ie. a yarn.lock inside a subfolder of
    // a yarn.lock). This is typically solved using workspaces, but
    // not all of them have been converted already.

    if (issuer && isPathIgnored(issuer)) {
      // Absolute paths that seem to belong to a PnP tree are still
      // handled by our runtime even if the issuer isn't. This is
      // because the native Node resolution uses a special version
      // of the `stat` syscall which would otherwise bypass the
      // filesystem layer we require to access the files.
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);

        if (result === false) {
          throw internalTools_makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)\n\nRequire request: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        return npath.toPortablePath(result);
      }
    }

    let unqualifiedPath; // If the request is a relative or absolute path, we just return it normalized

    const dependencyNameMatch = request.match(pathRegExp);

    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw internalTools_makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        } // We use ppath.join instead of ppath.resolve because:
        // 1) The request is a relative path in this branch
        // 2) ppath.join preserves trailing slashes


        const absoluteIssuer = ppath.resolve(issuer);

        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      // Things are more hairy if it's a package require - we then need to figure out which package is needed, and in
      // particular the exact version for the given location on the dependency tree
      if (!issuer) {
        throw internalTools_makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
          request: requestForDisplay,
          issuer: issuerForDisplay
        });
      }

      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer); // If the issuer file doesn't seem to be owned by a package managed through pnp, then we resort to using the next
      // resolution algorithm in the chain, usually the native Node resolution one

      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);

        if (result === false) {
          throw internalTools_makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).\n\nRequire path: "${requestForDisplay}"\nRequired by: ${issuerForDisplay}\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay
          });
        }

        return npath.toPortablePath(result);
      }

      const issuerInformation = getPackageInformationSafe(issuerLocator); // We obtain the dependency reference in regard to the package that request it

      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null; // If we can't find it, we check if we can potentially load it from the packages that have been defined as potential fallbacks.
      // It's a bit of a hack, but it improves compatibility with the existing Node ecosystem. Hopefully we should eventually be able
      // to kill this logic and become stricter once pnp gets enough traction and the affected packages fix themselves.

      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          // To allow programs to become gradually stricter, starting from the v2 we enforce that workspaces cannot depend on fallbacks.
          // This works by having a list containing all their locators, and checking when a fallback is required whether it's one of them.
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);

          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null) continue;
              if (alwaysWarnOnFallback) fallbackReference = reference;else dependencyReference = reference;
              break;
            }

            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);

                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      } // If we can't find the path, and if the package making the request is the top-level, we can offer nicer error messages


      let error = null;

      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = internalTools_makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerForDisplay}\n`, {
            request: requestForDisplay,
            issuer: issuerForDisplay,
            dependencyName
          });
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);

          if (brokenAncestors.every(ancestor => isDependencyTreeRoot(ancestor))) {
            error = internalTools_makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName,
              brokenAncestors
            });
          } else {
            error = internalTools_makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n\n${brokenAncestors.map(ancestorLocator => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}\n`).join(``)}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName,
              brokenAncestors
            });
          }
        }
      } else if (dependencyReference === undefined) {
        if (!considerBuiltins && isBuiltinModule(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              dependencyName
            });
          } else {
            error = internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName
            });
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerForDisplay}\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              dependencyName
            });
          } else {
            error = internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.\n\nRequired package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
              request: requestForDisplay,
              issuer: issuerForDisplay,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName
            });
          }
        }
      }

      if (dependencyReference == null) {
        if (fallbackReference === null || error === null) throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;

        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      } // We need to check that the package exists on the filesystem, because it might not have been installed


      const dependencyLocator = Array.isArray(dependencyReference) ? {
        name: dependencyReference[0],
        reference: dependencyReference[1]
      } : {
        name: dependencyName,
        reference: dependencyReference
      };
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);

      if (!dependencyInformation.packageLocation) {
        throw internalTools_makeError(ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.\n\nRequired package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})\n`, {
          request: requestForDisplay,
          issuer: issuerForDisplay,
          dependencyLocator: Object.assign({}, dependencyLocator)
        });
      } // Now that we know which package we should resolve to, we only have to find out the file location
      // packageLocation is always absolute as it's returned by getPackageInformationSafe


      const dependencyLocation = dependencyInformation.packageLocation;

      if (subPath) {
        // We use ppath.join instead of ppath.resolve because:
        // 1) subPath is always a relative path
        // 2) ppath.join preserves trailing slashes
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }

    return ppath.normalize(unqualifiedPath);
  }

  function resolveUnqualifiedExport(request, unqualifiedPath) {
    // "exports" only apply when requiring a package, not when requiring via an absolute / relative path
    if (isStrictRegExp.test(request)) return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath);

    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  /**
   * Transforms an unqualified path into a qualified path by using the Node resolution algorithm (which automatically
   * appends ".js" / ".json", and transforms directory accesses into "index.js").
   */


  function resolveUnqualified(unqualifiedPath, {
    extensions = Object.keys(external_module_namespaceObject.Module._extensions)
  } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {
      extensions
    });

    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      throw internalTools_makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Qualified path resolution failed - none of those files can be found on the disk.\n\nSource path: ${unqualifiedPathForDisplay}\n${candidates.map(candidate => `Not found: ${getPathForDisplay(candidate)}\n`).join(``)}`, {
        unqualifiedPath: unqualifiedPathForDisplay
      });
    }
  }
  /**
   * Transforms a request into a fully qualified path.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveRequest(request, issuer, {
    considerBuiltins,
    extensions
  } = {}) {
    const unqualifiedPath = resolveToUnqualified(request, issuer, {
      considerBuiltins
    });
    if (unqualifiedPath === null) return null;

    const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;

    const remappedPath = (!considerBuiltins || !isBuiltinModule(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath) : unqualifiedPath;

    try {
      return resolveUnqualified(remappedPath, {
        extensions
      });
    } catch (resolutionError) {
      if (resolutionError.pnpCode === `QUALIFIED_PATH_RESOLUTION_FAILED`) Object.assign(resolutionError.data, {
        request: getPathForDisplay(request),
        issuer: issuer && getPathForDisplay(issuer)
      });
      throw resolutionError;
    }
  }

  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }

  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return {
          name: referencish[0],
          reference: referencish[1]
        };
      } else {
        return {
          name,
          reference: referencish
        };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },

    getAllLocators() {
      const locators = [];

      for (const [name, entry] of packageRegistry) for (const reference of entry.keys()) if (name !== null && reference !== null) locators.push({
        name,
        reference
      });

      return locators;
    },

    getPackageInformation: locator => {
      const info = getPackageInformation(locator);
      if (info === null) return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = { ...info,
        packageLocation
      };
      return nativeInfo;
    },
    findPackageLocator: path => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, path => {
      const result = resolveVirtual(npath.toPortablePath(path));

      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}
// CONCATENATED MODULE: ./sources/hydratePnpApi.ts





const readFileP = (0,external_util_namespaceObject.promisify)(external_fs_namespaceObject.readFile); // Note that using those functions is typically NOT needed! The PnP API is
// designed to be consumed directly from within Node - meaning that depending
// on your situation you probably should use one of those two alternatives
// instead:
//
//   - If your script is executing within a PnP environment, you'll be able to
//     simply `require("pnpapi")` in order to get a reference to the running
//     API. You can also simply check whether you're actually running within a
//     PnP environment by checking `process.versions.pnp`.
//
//   - Or if you're not running within a PnP environment, or wish to interact
//     with a different one than the current one, then you can directly require
//     its `.pnp.cjs` file.
//
// The function exported in this file only work when the PnP data are kept
// outside of the loader (pnpEnableInlining = false in Yarn), and their only
// real use case is to access the PnP API without running the risk of executing
// third-party Javascript code.

async function hydratePnpFile(location, {
  fakeFs,
  pnpapiResolution
}) {
  const source = await readFileP(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: (0,external_path_namespaceObject.dirname)(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, {
  basePath,
  fakeFs,
  pnpapiResolution
}) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}
// CONCATENATED MODULE: ./sources/makeRuntimeApi.ts




const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, {
    basePath
  });
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, {
    fakeFs,
    pnpapiResolution
  });
};
// CONCATENATED MODULE: ./sources/index.ts





/***/ }),

/***/ 650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let hook;

module.exports = () => {
  if (typeof hook === `undefined`)
    hook = __webpack_require__(761).brotliDecompressSync(Buffer.from('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', 'base64')).toString();

  return hook;
};


/***/ }),

/***/ 761:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(40);
/******/ })()
;